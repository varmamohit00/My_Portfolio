{
  "version": 3,
  "sources": ["../../@tsparticles/move-base/browser/Utils.js", "../../@tsparticles/move-base/browser/BaseMover.js", "../../@tsparticles/move-base/browser/index.js", "../../@tsparticles/shape-circle/browser/Utils.js", "../../@tsparticles/shape-circle/browser/CircleDrawer.js", "../../@tsparticles/shape-circle/browser/index.js", "../../@tsparticles/updater-color/browser/ColorUpdater.js", "../../@tsparticles/updater-color/browser/index.js", "../../@tsparticles/plugin-hex-color/browser/HexColorManager.js", "../../@tsparticles/plugin-hex-color/browser/index.js", "../../@tsparticles/plugin-hsl-color/browser/HslColorManager.js", "../../@tsparticles/plugin-hsl-color/browser/index.js", "../../@tsparticles/updater-opacity/browser/OpacityUpdater.js", "../../@tsparticles/updater-opacity/browser/index.js", "../../@tsparticles/updater-out-modes/browser/Utils.js", "../../@tsparticles/updater-out-modes/browser/BounceOutMode.js", "../../@tsparticles/updater-out-modes/browser/DestroyOutMode.js", "../../@tsparticles/updater-out-modes/browser/NoneOutMode.js", "../../@tsparticles/updater-out-modes/browser/OutOutMode.js", "../../@tsparticles/updater-out-modes/browser/OutOfCanvasUpdater.js", "../../@tsparticles/updater-out-modes/browser/index.js", "../../@tsparticles/plugin-rgb-color/browser/RgbColorManager.js", "../../@tsparticles/plugin-rgb-color/browser/index.js", "../../@tsparticles/updater-size/browser/SizeUpdater.js", "../../@tsparticles/updater-size/browser/index.js", "../../@tsparticles/basic/browser/index.js"],
  "sourcesContent": ["import { RotateDirection, clamp, getDistance, getDistances, getRandom, getRangeValue, } from \"@tsparticles/engine\";\nconst half = 0.5, double = 2, minVelocity = 0, identity = 1, moveSpeedFactor = 60, minSpinRadius = 0, spinFactor = 0.01, doublePI = Math.PI * double;\nexport function applyDistance(particle) {\n    const initialPosition = particle.initialPosition, { dx, dy } = getDistances(initialPosition, particle.position), dxFixed = Math.abs(dx), dyFixed = Math.abs(dy), { maxDistance } = particle.retina, hDistance = maxDistance.horizontal, vDistance = maxDistance.vertical;\n    if (!hDistance && !vDistance) {\n        return;\n    }\n    const hasHDistance = (hDistance && dxFixed >= hDistance) ?? false, hasVDistance = (vDistance && dyFixed >= vDistance) ?? false;\n    if ((hasHDistance || hasVDistance) && !particle.misplaced) {\n        particle.misplaced = (!!hDistance && dxFixed > hDistance) || (!!vDistance && dyFixed > vDistance);\n        if (hDistance) {\n            particle.velocity.x = particle.velocity.y * half - particle.velocity.x;\n        }\n        if (vDistance) {\n            particle.velocity.y = particle.velocity.x * half - particle.velocity.y;\n        }\n    }\n    else if ((!hDistance || dxFixed < hDistance) && (!vDistance || dyFixed < vDistance) && particle.misplaced) {\n        particle.misplaced = false;\n    }\n    else if (particle.misplaced) {\n        const pos = particle.position, vel = particle.velocity;\n        if (hDistance &&\n            ((pos.x < initialPosition.x && vel.x < minVelocity) || (pos.x > initialPosition.x && vel.x > minVelocity))) {\n            vel.x *= -getRandom();\n        }\n        if (vDistance &&\n            ((pos.y < initialPosition.y && vel.y < minVelocity) || (pos.y > initialPosition.y && vel.y > minVelocity))) {\n            vel.y *= -getRandom();\n        }\n    }\n}\nexport function move(particle, moveOptions, moveSpeed, maxSpeed, moveDrift, delta) {\n    applyPath(particle, delta);\n    const gravityOptions = particle.gravity, gravityFactor = gravityOptions?.enable && gravityOptions.inverse ? -identity : identity;\n    if (moveDrift && moveSpeed) {\n        particle.velocity.x += (moveDrift * delta.factor) / (moveSpeedFactor * moveSpeed);\n    }\n    if (gravityOptions?.enable && moveSpeed) {\n        particle.velocity.y +=\n            (gravityFactor * (gravityOptions.acceleration * delta.factor)) / (moveSpeedFactor * moveSpeed);\n    }\n    const decay = particle.moveDecay;\n    particle.velocity.multTo(decay);\n    const velocity = particle.velocity.mult(moveSpeed);\n    if (gravityOptions?.enable &&\n        maxSpeed > minVelocity &&\n        ((!gravityOptions.inverse && velocity.y >= minVelocity && velocity.y >= maxSpeed) ||\n            (gravityOptions.inverse && velocity.y <= minVelocity && velocity.y <= -maxSpeed))) {\n        velocity.y = gravityFactor * maxSpeed;\n        if (moveSpeed) {\n            particle.velocity.y = velocity.y / moveSpeed;\n        }\n    }\n    const zIndexOptions = particle.options.zIndex, zVelocityFactor = (identity - particle.zIndexFactor) ** zIndexOptions.velocityRate;\n    velocity.multTo(zVelocityFactor);\n    const { position } = particle;\n    position.addTo(velocity);\n    if (moveOptions.vibrate) {\n        position.x += Math.sin(position.x * Math.cos(position.y));\n        position.y += Math.cos(position.y * Math.sin(position.x));\n    }\n}\nexport function spin(particle, moveSpeed) {\n    const container = particle.container;\n    if (!particle.spin) {\n        return;\n    }\n    const spinClockwise = particle.spin.direction === RotateDirection.clockwise, updateFunc = {\n        x: spinClockwise ? Math.cos : Math.sin,\n        y: spinClockwise ? Math.sin : Math.cos,\n    };\n    particle.position.x = particle.spin.center.x + particle.spin.radius * updateFunc.x(particle.spin.angle);\n    particle.position.y = particle.spin.center.y + particle.spin.radius * updateFunc.y(particle.spin.angle);\n    particle.spin.radius += particle.spin.acceleration;\n    const maxCanvasSize = Math.max(container.canvas.size.width, container.canvas.size.height), halfMaxSize = maxCanvasSize * half;\n    if (particle.spin.radius > halfMaxSize) {\n        particle.spin.radius = halfMaxSize;\n        particle.spin.acceleration *= -identity;\n    }\n    else if (particle.spin.radius < minSpinRadius) {\n        particle.spin.radius = minSpinRadius;\n        particle.spin.acceleration *= -identity;\n    }\n    particle.spin.angle += moveSpeed * spinFactor * (identity - particle.spin.radius / maxCanvasSize);\n}\nexport function applyPath(particle, delta) {\n    const particlesOptions = particle.options, pathOptions = particlesOptions.move.path, pathEnabled = pathOptions.enable;\n    if (!pathEnabled) {\n        return;\n    }\n    if (particle.lastPathTime <= particle.pathDelay) {\n        particle.lastPathTime += delta.value;\n        return;\n    }\n    const path = particle.pathGenerator?.generate(particle, delta);\n    if (path) {\n        particle.velocity.addTo(path);\n    }\n    if (pathOptions.clamp) {\n        particle.velocity.x = clamp(particle.velocity.x, -identity, identity);\n        particle.velocity.y = clamp(particle.velocity.y, -identity, identity);\n    }\n    particle.lastPathTime -= particle.pathDelay;\n}\nexport function getProximitySpeedFactor(particle) {\n    return particle.slow.inRange ? particle.slow.factor : identity;\n}\nexport function initSpin(particle) {\n    const container = particle.container, options = particle.options, spinOptions = options.move.spin;\n    if (!spinOptions.enable) {\n        return;\n    }\n    const spinPos = spinOptions.position ?? { x: 50, y: 50 }, spinFactor = 0.01, spinCenter = {\n        x: spinPos.x * spinFactor * container.canvas.size.width,\n        y: spinPos.y * spinFactor * container.canvas.size.height,\n    }, pos = particle.getPosition(), distance = getDistance(pos, spinCenter), spinAcceleration = getRangeValue(spinOptions.acceleration);\n    particle.retina.spinAcceleration = spinAcceleration * container.retina.pixelRatio;\n    particle.spin = {\n        center: spinCenter,\n        direction: particle.velocity.x >= minVelocity ? RotateDirection.clockwise : RotateDirection.counterClockwise,\n        angle: getRandom() * doublePI,\n        radius: distance,\n        acceleration: particle.retina.spinAcceleration,\n    };\n}\n", "import { getRangeMax, getRangeValue } from \"@tsparticles/engine\";\nimport { applyDistance, getProximitySpeedFactor, initSpin, move, spin } from \"./Utils.js\";\nconst diffFactor = 2, defaultSizeFactor = 1, defaultDeltaFactor = 1;\nexport class BaseMover {\n    init(particle) {\n        const options = particle.options, gravityOptions = options.move.gravity;\n        particle.gravity = {\n            enable: gravityOptions.enable,\n            acceleration: getRangeValue(gravityOptions.acceleration),\n            inverse: gravityOptions.inverse,\n        };\n        initSpin(particle);\n    }\n    isEnabled(particle) {\n        return !particle.destroyed && particle.options.move.enable;\n    }\n    move(particle, delta) {\n        const particleOptions = particle.options, moveOptions = particleOptions.move;\n        if (!moveOptions.enable) {\n            return;\n        }\n        const container = particle.container, pxRatio = container.retina.pixelRatio;\n        particle.retina.moveSpeed ??= getRangeValue(moveOptions.speed) * pxRatio;\n        particle.retina.moveDrift ??= getRangeValue(particle.options.move.drift) * pxRatio;\n        const slowFactor = getProximitySpeedFactor(particle), baseSpeed = particle.retina.moveSpeed * container.retina.reduceFactor, moveDrift = particle.retina.moveDrift, maxSize = getRangeMax(particleOptions.size.value) * pxRatio, sizeFactor = moveOptions.size ? particle.getRadius() / maxSize : defaultSizeFactor, deltaFactor = delta.factor || defaultDeltaFactor, moveSpeed = (baseSpeed * sizeFactor * slowFactor * deltaFactor) / diffFactor, maxSpeed = particle.retina.maxSpeed ?? container.retina.maxSpeed;\n        if (moveOptions.spin.enable) {\n            spin(particle, moveSpeed);\n        }\n        else {\n            move(particle, moveOptions, moveSpeed, maxSpeed, moveDrift, delta);\n        }\n        applyDistance(particle);\n    }\n}\n", "import { BaseMover } from \"./BaseMover.js\";\nexport async function loadBaseMover(engine, refresh = true) {\n    engine.checkVersion(\"3.8.1\");\n    await engine.addMover(\"base\", () => {\n        return Promise.resolve(new BaseMover());\n    }, refresh);\n}\n", "const double = 2, doublePI = Math.PI * double, minAngle = 0, origin = { x: 0, y: 0 };\nexport function drawCircle(data) {\n    const { context, particle, radius } = data;\n    if (!particle.circleRange) {\n        particle.circleRange = { min: minAngle, max: doublePI };\n    }\n    const circleRange = particle.circleRange;\n    context.arc(origin.x, origin.y, radius, circleRange.min, circleRange.max, false);\n}\n", "import { degToRad, isObject } from \"@tsparticles/engine\";\nimport { drawCircle } from \"./Utils.js\";\nconst sides = 12, maxAngle = 360, minAngle = 0;\nexport class CircleDrawer {\n    constructor() {\n        this.validTypes = [\"circle\"];\n    }\n    draw(data) {\n        drawCircle(data);\n    }\n    getSidesCount() {\n        return sides;\n    }\n    particleInit(container, particle) {\n        const shapeData = particle.shapeData, angle = shapeData?.angle ?? {\n            max: maxAngle,\n            min: minAngle,\n        };\n        particle.circleRange = !isObject(angle)\n            ? {\n                min: minAngle,\n                max: degToRad(angle),\n            }\n            : { min: degToRad(angle.min), max: degToRad(angle.max) };\n    }\n}\n", "import { CircleDrawer } from \"./CircleDrawer.js\";\nexport async function loadCircleShape(engine, refresh = true) {\n    engine.checkVersion(\"3.8.1\");\n    await engine.addShape(new CircleDrawer(), refresh);\n}\n", "import { getHslAnimationFromHsl, rangeColorToHsl, updateColor, } from \"@tsparticles/engine\";\nexport class ColorUpdater {\n    constructor(container, engine) {\n        this._container = container;\n        this._engine = engine;\n    }\n    init(particle) {\n        const hslColor = rangeColorToHsl(this._engine, particle.options.color, particle.id, particle.options.reduceDuplicates);\n        if (hslColor) {\n            particle.color = getHslAnimationFromHsl(hslColor, particle.options.color.animation, this._container.retina.reduceFactor);\n        }\n    }\n    isEnabled(particle) {\n        const { h: hAnimation, s: sAnimation, l: lAnimation } = particle.options.color.animation, { color } = particle;\n        return (!particle.destroyed &&\n            !particle.spawning &&\n            ((color?.h.value !== undefined && hAnimation.enable) ||\n                (color?.s.value !== undefined && sAnimation.enable) ||\n                (color?.l.value !== undefined && lAnimation.enable)));\n    }\n    update(particle, delta) {\n        updateColor(particle.color, delta);\n    }\n}\n", "import { ColorUpdater } from \"./ColorUpdater.js\";\nexport async function loadColorUpdater(engine, refresh = true) {\n    engine.checkVersion(\"3.8.1\");\n    await engine.addParticleUpdater(\"color\", container => {\n        return Promise.resolve(new ColorUpdater(container, engine));\n    }, refresh);\n}\n", "var RgbIndexes;\n(function (RgbIndexes) {\n    RgbIndexes[RgbIndexes[\"r\"] = 1] = \"r\";\n    RgbIndexes[RgbIndexes[\"g\"] = 2] = \"g\";\n    RgbIndexes[RgbIndexes[\"b\"] = 3] = \"b\";\n    RgbIndexes[RgbIndexes[\"a\"] = 4] = \"a\";\n})(RgbIndexes || (RgbIndexes = {}));\nconst shorthandHexRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])([a-f\\d])?$/i, hexRegex = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})?$/i, hexRadix = 16, defaultAlpha = 1, alphaFactor = 0xff;\nexport class HexColorManager {\n    constructor() {\n        this.key = \"hex\";\n        this.stringPrefix = \"#\";\n    }\n    handleColor(color) {\n        return this._parseString(color.value);\n    }\n    handleRangeColor(color) {\n        return this._parseString(color.value);\n    }\n    parseString(input) {\n        return this._parseString(input);\n    }\n    _parseString(hexColor) {\n        if (typeof hexColor !== \"string\") {\n            return;\n        }\n        if (!hexColor?.startsWith(this.stringPrefix)) {\n            return;\n        }\n        const hexFixed = hexColor.replace(shorthandHexRegex, (_, r, g, b, a) => {\n            return r + r + g + g + b + b + (a !== undefined ? a + a : \"\");\n        }), result = hexRegex.exec(hexFixed);\n        return result\n            ? {\n                a: result[RgbIndexes.a] !== undefined\n                    ? parseInt(result[RgbIndexes.a], hexRadix) / alphaFactor\n                    : defaultAlpha,\n                b: parseInt(result[RgbIndexes.b], hexRadix),\n                g: parseInt(result[RgbIndexes.g], hexRadix),\n                r: parseInt(result[RgbIndexes.r], hexRadix),\n            }\n            : undefined;\n    }\n}\n", "import { HexColorManager } from \"./HexColorManager.js\";\nexport async function loadHexColorPlugin(engine, refresh = true) {\n    engine.checkVersion(\"3.8.1\");\n    await engine.addColorManager(new HexColorManager(), refresh);\n}\n", "import { getRangeValue, hslToRgb, hslaToRgba, parseAlpha, } from \"@tsparticles/engine\";\nvar HslIndexes;\n(function (HslIndexes) {\n    HslIndexes[HslIndexes[\"h\"] = 1] = \"h\";\n    HslIndexes[HslIndexes[\"s\"] = 2] = \"s\";\n    HslIndexes[HslIndexes[\"l\"] = 3] = \"l\";\n    HslIndexes[HslIndexes[\"a\"] = 5] = \"a\";\n})(HslIndexes || (HslIndexes = {}));\nexport class HslColorManager {\n    constructor() {\n        this.key = \"hsl\";\n        this.stringPrefix = \"hsl\";\n    }\n    handleColor(color) {\n        const colorValue = color.value, hslColor = colorValue.hsl ?? color.value;\n        if (hslColor.h !== undefined && hslColor.s !== undefined && hslColor.l !== undefined) {\n            return hslToRgb(hslColor);\n        }\n    }\n    handleRangeColor(color) {\n        const colorValue = color.value, hslColor = colorValue.hsl ?? color.value;\n        if (hslColor.h !== undefined && hslColor.l !== undefined) {\n            return hslToRgb({\n                h: getRangeValue(hslColor.h),\n                l: getRangeValue(hslColor.l),\n                s: getRangeValue(hslColor.s),\n            });\n        }\n    }\n    parseString(input) {\n        if (!input.startsWith(\"hsl\")) {\n            return;\n        }\n        const regex = /hsla?\\(\\s*(\\d+)\\s*[\\s,]\\s*(\\d+)%\\s*[\\s,]\\s*(\\d+)%\\s*([\\s,]\\s*(0|1|0?\\.\\d+|(\\d{1,3})%)\\s*)?\\)/i, result = regex.exec(input), minLength = 4, defaultAlpha = 1, radix = 10;\n        return result\n            ? hslaToRgba({\n                a: result.length > minLength ? parseAlpha(result[HslIndexes.a]) : defaultAlpha,\n                h: parseInt(result[HslIndexes.h], radix),\n                l: parseInt(result[HslIndexes.l], radix),\n                s: parseInt(result[HslIndexes.s], radix),\n            })\n            : undefined;\n    }\n}\n", "import { HslColorManager } from \"./HslColorManager.js\";\nexport async function loadHslColorPlugin(engine, refresh = true) {\n    engine.checkVersion(\"3.8.1\");\n    await engine.addColorManager(new HslColorManager(), refresh);\n}\n", "import { getRandom, getRangeValue, initParticleNumericAnimationValue, percentDenominator, updateAnimation, } from \"@tsparticles/engine\";\nexport class OpacityUpdater {\n    constructor(container) {\n        this.container = container;\n    }\n    init(particle) {\n        const opacityOptions = particle.options.opacity, pxRatio = 1;\n        particle.opacity = initParticleNumericAnimationValue(opacityOptions, pxRatio);\n        const opacityAnimation = opacityOptions.animation;\n        if (opacityAnimation.enable) {\n            particle.opacity.velocity =\n                (getRangeValue(opacityAnimation.speed) / percentDenominator) * this.container.retina.reduceFactor;\n            if (!opacityAnimation.sync) {\n                particle.opacity.velocity *= getRandom();\n            }\n        }\n    }\n    isEnabled(particle) {\n        const none = 0;\n        return (!particle.destroyed &&\n            !particle.spawning &&\n            !!particle.opacity &&\n            particle.opacity.enable &&\n            ((particle.opacity.maxLoops ?? none) <= none ||\n                ((particle.opacity.maxLoops ?? none) > none &&\n                    (particle.opacity.loops ?? none) < (particle.opacity.maxLoops ?? none))));\n    }\n    reset(particle) {\n        if (particle.opacity) {\n            particle.opacity.time = 0;\n            particle.opacity.loops = 0;\n        }\n    }\n    update(particle, delta) {\n        if (!this.isEnabled(particle) || !particle.opacity) {\n            return;\n        }\n        updateAnimation(particle, particle.opacity, true, particle.options.opacity.animation.destroy, delta);\n    }\n}\n", "import { OpacityUpdater } from \"./OpacityUpdater.js\";\nexport async function loadOpacityUpdater(engine, refresh = true) {\n    engine.checkVersion(\"3.8.1\");\n    await engine.addParticleUpdater(\"opacity\", container => {\n        return Promise.resolve(new OpacityUpdater(container));\n    }, refresh);\n}\n", "import { OutMode, OutModeDirection, getRangeValue } from \"@tsparticles/engine\";\nconst minVelocity = 0, boundsMin = 0;\nexport function bounceHorizontal(data) {\n    if ((data.outMode !== OutMode.bounce && data.outMode !== OutMode.split) ||\n        (data.direction !== OutModeDirection.left && data.direction !== OutModeDirection.right)) {\n        return;\n    }\n    if (data.bounds.right < boundsMin && data.direction === OutModeDirection.left) {\n        data.particle.position.x = data.size + data.offset.x;\n    }\n    else if (data.bounds.left > data.canvasSize.width && data.direction === OutModeDirection.right) {\n        data.particle.position.x = data.canvasSize.width - data.size - data.offset.x;\n    }\n    const velocity = data.particle.velocity.x;\n    let bounced = false;\n    if ((data.direction === OutModeDirection.right &&\n        data.bounds.right >= data.canvasSize.width &&\n        velocity > minVelocity) ||\n        (data.direction === OutModeDirection.left && data.bounds.left <= boundsMin && velocity < minVelocity)) {\n        const newVelocity = getRangeValue(data.particle.options.bounce.horizontal.value);\n        data.particle.velocity.x *= -newVelocity;\n        bounced = true;\n    }\n    if (!bounced) {\n        return;\n    }\n    const minPos = data.offset.x + data.size;\n    if (data.bounds.right >= data.canvasSize.width && data.direction === OutModeDirection.right) {\n        data.particle.position.x = data.canvasSize.width - minPos;\n    }\n    else if (data.bounds.left <= boundsMin && data.direction === OutModeDirection.left) {\n        data.particle.position.x = minPos;\n    }\n    if (data.outMode === OutMode.split) {\n        data.particle.destroy();\n    }\n}\nexport function bounceVertical(data) {\n    if ((data.outMode !== OutMode.bounce && data.outMode !== OutMode.split) ||\n        (data.direction !== OutModeDirection.bottom && data.direction !== OutModeDirection.top)) {\n        return;\n    }\n    if (data.bounds.bottom < boundsMin && data.direction === OutModeDirection.top) {\n        data.particle.position.y = data.size + data.offset.y;\n    }\n    else if (data.bounds.top > data.canvasSize.height && data.direction === OutModeDirection.bottom) {\n        data.particle.position.y = data.canvasSize.height - data.size - data.offset.y;\n    }\n    const velocity = data.particle.velocity.y;\n    let bounced = false;\n    if ((data.direction === OutModeDirection.bottom &&\n        data.bounds.bottom >= data.canvasSize.height &&\n        velocity > minVelocity) ||\n        (data.direction === OutModeDirection.top && data.bounds.top <= boundsMin && velocity < minVelocity)) {\n        const newVelocity = getRangeValue(data.particle.options.bounce.vertical.value);\n        data.particle.velocity.y *= -newVelocity;\n        bounced = true;\n    }\n    if (!bounced) {\n        return;\n    }\n    const minPos = data.offset.y + data.size;\n    if (data.bounds.bottom >= data.canvasSize.height && data.direction === OutModeDirection.bottom) {\n        data.particle.position.y = data.canvasSize.height - minPos;\n    }\n    else if (data.bounds.top <= boundsMin && data.direction === OutModeDirection.top) {\n        data.particle.position.y = minPos;\n    }\n    if (data.outMode === OutMode.split) {\n        data.particle.destroy();\n    }\n}\n", "import { OutMode, calculateBounds, } from \"@tsparticles/engine\";\nimport { bounceHorizontal, bounceVertical } from \"./Utils.js\";\nexport class BounceOutMode {\n    constructor(container) {\n        this.container = container;\n        this.modes = [\n            OutMode.bounce,\n            OutMode.split,\n        ];\n    }\n    update(particle, direction, delta, outMode) {\n        if (!this.modes.includes(outMode)) {\n            return;\n        }\n        const container = this.container;\n        let handled = false;\n        for (const plugin of container.plugins.values()) {\n            if (plugin.particleBounce !== undefined) {\n                handled = plugin.particleBounce(particle, delta, direction);\n            }\n            if (handled) {\n                break;\n            }\n        }\n        if (handled) {\n            return;\n        }\n        const pos = particle.getPosition(), offset = particle.offset, size = particle.getRadius(), bounds = calculateBounds(pos, size), canvasSize = container.canvas.size;\n        bounceHorizontal({ particle, outMode, direction, bounds, canvasSize, offset, size });\n        bounceVertical({ particle, outMode, direction, bounds, canvasSize, offset, size });\n    }\n}\n", "import { OutMode, ParticleOutType, Vector, getDistances, isPointInside, } from \"@tsparticles/engine\";\nconst minVelocity = 0;\nexport class DestroyOutMode {\n    constructor(container) {\n        this.container = container;\n        this.modes = [OutMode.destroy];\n    }\n    update(particle, direction, _delta, outMode) {\n        if (!this.modes.includes(outMode)) {\n            return;\n        }\n        const container = this.container;\n        switch (particle.outType) {\n            case ParticleOutType.normal:\n            case ParticleOutType.outside:\n                if (isPointInside(particle.position, container.canvas.size, Vector.origin, particle.getRadius(), direction)) {\n                    return;\n                }\n                break;\n            case ParticleOutType.inside: {\n                const { dx, dy } = getDistances(particle.position, particle.moveCenter), { x: vx, y: vy } = particle.velocity;\n                if ((vx < minVelocity && dx > particle.moveCenter.radius) ||\n                    (vy < minVelocity && dy > particle.moveCenter.radius) ||\n                    (vx >= minVelocity && dx < -particle.moveCenter.radius) ||\n                    (vy >= minVelocity && dy < -particle.moveCenter.radius)) {\n                    return;\n                }\n                break;\n            }\n        }\n        container.particles.remove(particle, particle.group, true);\n    }\n}\n", "import { OutMode, OutModeDirection, Vector, isPointInside, } from \"@tsparticles/engine\";\nconst minVelocity = 0;\nexport class NoneOutMode {\n    constructor(container) {\n        this.container = container;\n        this.modes = [OutMode.none];\n    }\n    update(particle, direction, delta, outMode) {\n        if (!this.modes.includes(outMode)) {\n            return;\n        }\n        if ((particle.options.move.distance.horizontal &&\n            (direction === OutModeDirection.left || direction === OutModeDirection.right)) ??\n            (particle.options.move.distance.vertical &&\n                (direction === OutModeDirection.top || direction === OutModeDirection.bottom))) {\n            return;\n        }\n        const gravityOptions = particle.options.move.gravity, container = this.container, canvasSize = container.canvas.size, pRadius = particle.getRadius();\n        if (!gravityOptions.enable) {\n            if ((particle.velocity.y > minVelocity && particle.position.y <= canvasSize.height + pRadius) ||\n                (particle.velocity.y < minVelocity && particle.position.y >= -pRadius) ||\n                (particle.velocity.x > minVelocity && particle.position.x <= canvasSize.width + pRadius) ||\n                (particle.velocity.x < minVelocity && particle.position.x >= -pRadius)) {\n                return;\n            }\n            if (!isPointInside(particle.position, container.canvas.size, Vector.origin, pRadius, direction)) {\n                container.particles.remove(particle);\n            }\n        }\n        else {\n            const position = particle.position;\n            if ((!gravityOptions.inverse &&\n                position.y > canvasSize.height + pRadius &&\n                direction === OutModeDirection.bottom) ||\n                (gravityOptions.inverse && position.y < -pRadius && direction === OutModeDirection.top)) {\n                container.particles.remove(particle);\n            }\n        }\n    }\n}\n", "import { OutMode, OutModeDirection, ParticleOutType, Vector, calculateBounds, getDistances, getRandom, isPointInside, randomInRange, } from \"@tsparticles/engine\";\nconst minVelocity = 0, minDistance = 0;\nexport class OutOutMode {\n    constructor(container) {\n        this.container = container;\n        this.modes = [OutMode.out];\n    }\n    update(particle, direction, delta, outMode) {\n        if (!this.modes.includes(outMode)) {\n            return;\n        }\n        const container = this.container;\n        switch (particle.outType) {\n            case ParticleOutType.inside: {\n                const { x: vx, y: vy } = particle.velocity;\n                const circVec = Vector.origin;\n                circVec.length = particle.moveCenter.radius;\n                circVec.angle = particle.velocity.angle + Math.PI;\n                circVec.addTo(Vector.create(particle.moveCenter));\n                const { dx, dy } = getDistances(particle.position, circVec);\n                if ((vx <= minVelocity && dx >= minDistance) ||\n                    (vy <= minVelocity && dy >= minDistance) ||\n                    (vx >= minVelocity && dx <= minDistance) ||\n                    (vy >= minVelocity && dy <= minDistance)) {\n                    return;\n                }\n                particle.position.x = Math.floor(randomInRange({\n                    min: 0,\n                    max: container.canvas.size.width,\n                }));\n                particle.position.y = Math.floor(randomInRange({\n                    min: 0,\n                    max: container.canvas.size.height,\n                }));\n                const { dx: newDx, dy: newDy } = getDistances(particle.position, particle.moveCenter);\n                particle.direction = Math.atan2(-newDy, -newDx);\n                particle.velocity.angle = particle.direction;\n                break;\n            }\n            default: {\n                if (isPointInside(particle.position, container.canvas.size, Vector.origin, particle.getRadius(), direction)) {\n                    return;\n                }\n                switch (particle.outType) {\n                    case ParticleOutType.outside: {\n                        particle.position.x =\n                            Math.floor(randomInRange({\n                                min: -particle.moveCenter.radius,\n                                max: particle.moveCenter.radius,\n                            })) + particle.moveCenter.x;\n                        particle.position.y =\n                            Math.floor(randomInRange({\n                                min: -particle.moveCenter.radius,\n                                max: particle.moveCenter.radius,\n                            })) + particle.moveCenter.y;\n                        const { dx, dy } = getDistances(particle.position, particle.moveCenter);\n                        if (particle.moveCenter.radius) {\n                            particle.direction = Math.atan2(dy, dx);\n                            particle.velocity.angle = particle.direction;\n                        }\n                        break;\n                    }\n                    case ParticleOutType.normal: {\n                        const warp = particle.options.move.warp, canvasSize = container.canvas.size, newPos = {\n                            bottom: canvasSize.height + particle.getRadius() + particle.offset.y,\n                            left: -particle.getRadius() - particle.offset.x,\n                            right: canvasSize.width + particle.getRadius() + particle.offset.x,\n                            top: -particle.getRadius() - particle.offset.y,\n                        }, sizeValue = particle.getRadius(), nextBounds = calculateBounds(particle.position, sizeValue);\n                        if (direction === OutModeDirection.right &&\n                            nextBounds.left > canvasSize.width + particle.offset.x) {\n                            particle.position.x = newPos.left;\n                            particle.initialPosition.x = particle.position.x;\n                            if (!warp) {\n                                particle.position.y = getRandom() * canvasSize.height;\n                                particle.initialPosition.y = particle.position.y;\n                            }\n                        }\n                        else if (direction === OutModeDirection.left && nextBounds.right < -particle.offset.x) {\n                            particle.position.x = newPos.right;\n                            particle.initialPosition.x = particle.position.x;\n                            if (!warp) {\n                                particle.position.y = getRandom() * canvasSize.height;\n                                particle.initialPosition.y = particle.position.y;\n                            }\n                        }\n                        if (direction === OutModeDirection.bottom &&\n                            nextBounds.top > canvasSize.height + particle.offset.y) {\n                            if (!warp) {\n                                particle.position.x = getRandom() * canvasSize.width;\n                                particle.initialPosition.x = particle.position.x;\n                            }\n                            particle.position.y = newPos.top;\n                            particle.initialPosition.y = particle.position.y;\n                        }\n                        else if (direction === OutModeDirection.top && nextBounds.bottom < -particle.offset.y) {\n                            if (!warp) {\n                                particle.position.x = getRandom() * canvasSize.width;\n                                particle.initialPosition.x = particle.position.x;\n                            }\n                            particle.position.y = newPos.bottom;\n                            particle.initialPosition.y = particle.position.y;\n                        }\n                        break;\n                    }\n                }\n                break;\n            }\n        }\n    }\n}\n", "import { OutMode, OutModeDirection, } from \"@tsparticles/engine\";\nimport { BounceOutMode } from \"./BounceOutMode.js\";\nimport { DestroyOutMode } from \"./DestroyOutMode.js\";\nimport { NoneOutMode } from \"./NoneOutMode.js\";\nimport { OutOutMode } from \"./OutOutMode.js\";\nconst checkOutMode = (outModes, outMode) => {\n    return (outModes.default === outMode ||\n        outModes.bottom === outMode ||\n        outModes.left === outMode ||\n        outModes.right === outMode ||\n        outModes.top === outMode);\n};\nexport class OutOfCanvasUpdater {\n    constructor(container) {\n        this._addUpdaterIfMissing = (particle, outMode, getUpdater) => {\n            const outModes = particle.options.move.outModes;\n            if (!this.updaters.has(outMode) && checkOutMode(outModes, outMode)) {\n                this.updaters.set(outMode, getUpdater(this.container));\n            }\n        };\n        this._updateOutMode = (particle, delta, outMode, direction) => {\n            for (const updater of this.updaters.values()) {\n                updater.update(particle, direction, delta, outMode);\n            }\n        };\n        this.container = container;\n        this.updaters = new Map();\n    }\n    init(particle) {\n        this._addUpdaterIfMissing(particle, OutMode.bounce, container => new BounceOutMode(container));\n        this._addUpdaterIfMissing(particle, OutMode.out, container => new OutOutMode(container));\n        this._addUpdaterIfMissing(particle, OutMode.destroy, container => new DestroyOutMode(container));\n        this._addUpdaterIfMissing(particle, OutMode.none, container => new NoneOutMode(container));\n    }\n    isEnabled(particle) {\n        return !particle.destroyed && !particle.spawning;\n    }\n    update(particle, delta) {\n        const outModes = particle.options.move.outModes;\n        this._updateOutMode(particle, delta, outModes.bottom ?? outModes.default, OutModeDirection.bottom);\n        this._updateOutMode(particle, delta, outModes.left ?? outModes.default, OutModeDirection.left);\n        this._updateOutMode(particle, delta, outModes.right ?? outModes.default, OutModeDirection.right);\n        this._updateOutMode(particle, delta, outModes.top ?? outModes.default, OutModeDirection.top);\n    }\n}\n", "import { OutOfCanvasUpdater } from \"./OutOfCanvasUpdater.js\";\nexport async function loadOutModesUpdater(engine, refresh = true) {\n    engine.checkVersion(\"3.8.1\");\n    await engine.addParticleUpdater(\"outModes\", container => {\n        return Promise.resolve(new OutOfCanvasUpdater(container));\n    }, refresh);\n}\n", "import { getRangeValue, parseAlpha, } from \"@tsparticles/engine\";\nvar RgbIndexes;\n(function (RgbIndexes) {\n    RgbIndexes[RgbIndexes[\"r\"] = 1] = \"r\";\n    RgbIndexes[RgbIndexes[\"g\"] = 2] = \"g\";\n    RgbIndexes[RgbIndexes[\"b\"] = 3] = \"b\";\n    RgbIndexes[RgbIndexes[\"a\"] = 5] = \"a\";\n})(RgbIndexes || (RgbIndexes = {}));\nexport class RgbColorManager {\n    constructor() {\n        this.key = \"rgb\";\n        this.stringPrefix = \"rgb\";\n    }\n    handleColor(color) {\n        const colorValue = color.value, rgbColor = colorValue.rgb ?? color.value;\n        if (rgbColor.r !== undefined) {\n            return rgbColor;\n        }\n    }\n    handleRangeColor(color) {\n        const colorValue = color.value, rgbColor = colorValue.rgb ?? color.value;\n        if (rgbColor.r !== undefined) {\n            return {\n                r: getRangeValue(rgbColor.r),\n                g: getRangeValue(rgbColor.g),\n                b: getRangeValue(rgbColor.b),\n            };\n        }\n    }\n    parseString(input) {\n        if (!input.startsWith(this.stringPrefix)) {\n            return;\n        }\n        const regex = /rgba?\\(\\s*(\\d{1,3})\\s*[\\s,]\\s*(\\d{1,3})\\s*[\\s,]\\s*(\\d{1,3})\\s*([\\s,]\\s*(0|1|0?\\.\\d+|(\\d{1,3})%)\\s*)?\\)/i, result = regex.exec(input), radix = 10, minLength = 4, defaultAlpha = 1;\n        return result\n            ? {\n                a: result.length > minLength ? parseAlpha(result[RgbIndexes.a]) : defaultAlpha,\n                b: parseInt(result[RgbIndexes.b], radix),\n                g: parseInt(result[RgbIndexes.g], radix),\n                r: parseInt(result[RgbIndexes.r], radix),\n            }\n            : undefined;\n    }\n}\n", "import { RgbColorManager } from \"./RgbColorManager.js\";\nexport async function loadRgbColorPlugin(engine, refresh = true) {\n    engine.checkVersion(\"3.8.1\");\n    await engine.addColorManager(new RgbColorManager(), refresh);\n}\n", "import { getRandom, percentDenominator, updateAnimation, } from \"@tsparticles/engine\";\nconst minLoops = 0;\nexport class SizeUpdater {\n    init(particle) {\n        const container = particle.container, sizeOptions = particle.options.size, sizeAnimation = sizeOptions.animation;\n        if (sizeAnimation.enable) {\n            particle.size.velocity =\n                ((particle.retina.sizeAnimationSpeed ?? container.retina.sizeAnimationSpeed) / percentDenominator) *\n                    container.retina.reduceFactor;\n            if (!sizeAnimation.sync) {\n                particle.size.velocity *= getRandom();\n            }\n        }\n    }\n    isEnabled(particle) {\n        return (!particle.destroyed &&\n            !particle.spawning &&\n            particle.size.enable &&\n            ((particle.size.maxLoops ?? minLoops) <= minLoops ||\n                ((particle.size.maxLoops ?? minLoops) > minLoops &&\n                    (particle.size.loops ?? minLoops) < (particle.size.maxLoops ?? minLoops))));\n    }\n    reset(particle) {\n        particle.size.loops = minLoops;\n    }\n    update(particle, delta) {\n        if (!this.isEnabled(particle)) {\n            return;\n        }\n        updateAnimation(particle, particle.size, true, particle.options.size.animation.destroy, delta);\n    }\n}\n", "import { SizeUpdater } from \"./SizeUpdater.js\";\nexport async function loadSizeUpdater(engine, refresh = true) {\n    engine.checkVersion(\"3.8.1\");\n    await engine.addParticleUpdater(\"size\", () => {\n        return Promise.resolve(new SizeUpdater());\n    }, refresh);\n}\n", "import { loadBaseMover } from \"@tsparticles/move-base\";\nimport { loadCircleShape } from \"@tsparticles/shape-circle\";\nimport { loadColorUpdater } from \"@tsparticles/updater-color\";\nimport { loadHexColorPlugin } from \"@tsparticles/plugin-hex-color\";\nimport { loadHslColorPlugin } from \"@tsparticles/plugin-hsl-color\";\nimport { loadOpacityUpdater } from \"@tsparticles/updater-opacity\";\nimport { loadOutModesUpdater } from \"@tsparticles/updater-out-modes\";\nimport { loadRgbColorPlugin } from \"@tsparticles/plugin-rgb-color\";\nimport { loadSizeUpdater } from \"@tsparticles/updater-size\";\nexport async function loadBasic(engine, refresh = true) {\n    engine.checkVersion(\"3.8.1\");\n    await loadHexColorPlugin(engine, false);\n    await loadHslColorPlugin(engine, false);\n    await loadRgbColorPlugin(engine, false);\n    await loadBaseMover(engine, false);\n    await loadCircleShape(engine, false);\n    await loadColorUpdater(engine, false);\n    await loadOpacityUpdater(engine, false);\n    await loadOutModesUpdater(engine, false);\n    await loadSizeUpdater(engine, false);\n    await engine.refresh(refresh);\n}\n"],
  "mappings": "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",
  "names": ["spinFactor", "double", "doublePI", "minAngle", "RgbIndexes", "HslIndexes", "defaultAlpha", "minVelocity", "minVelocity", "minVelocity", "minVelocity", "RgbIndexes", "defaultAlpha"]
}
